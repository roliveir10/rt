
<!-- saved from url=(0063)http://heigeas.free.fr/laure/ray_tracing/realisation.htm#perlin -->
<html><!-- #BeginTemplate "/Templates/modele.dwt" --><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<!-- #BeginEditable "doctitle" --> 
<title>REALISATION - Ray Tracing</title>
<!-- #EndEditable -->
<meta http-equiv="Content-Type" content="text/html; charset=">
<script language="JavaScript">
<!--
function MM_swapImgRestore() { //v3.0
  var i,x,a=document.MM_sr; for(i=0;a&&i<a.length&&(x=a[i])&&x.oSrc;i++) x.src=x.oSrc;
}

function MM_preloadImages() { //v3.0
  var d=document; if(d.images){ if(!d.MM_p) d.MM_p=new Array();
    var i,j=d.MM_p.length,a=MM_preloadImages.arguments; for(i=0; i<a.length; i++)
    if (a[i].indexOf("#")!=0){ d.MM_p[j]=new Image; d.MM_p[j++].src=a[i];}}
}

function MM_findObj(n, d) { //v4.0
  var p,i,x;  if(!d) d=document; if((p=n.indexOf("?"))>0&&parent.frames.length) {
    d=parent.frames[n.substring(p+1)].document; n=n.substring(0,p);}
  if(!(x=d[n])&&d.all) x=d.all[n]; for (i=0;!x&&i<d.forms.length;i++) x=d.forms[i][n];
  for(i=0;!x&&d.layers&&i<d.layers.length;i++) x=MM_findObj(n,d.layers[i].document);
  if(!x && document.getElementById) x=document.getElementById(n); return x;
}

function MM_swapImage() { //v3.0
  var i,j=0,x,a=MM_swapImage.arguments; document.MM_sr=new Array; for(i=0;i<(a.length-2);i+=3)
   if ((x=MM_findObj(a[i]))!=null){document.MM_sr[j++]=x; if(!x.oSrc) x.oSrc=x.src; x.src=a[i+2];}
}
//-->
</script>
<link rel="stylesheet" href="./REALISATION - Ray Tracing_files/ray.css" type="text/css">
</head>

<body bgcolor="#FFFFFF" text="#000000" onload="MM_preloadImages(&#39;images/intro_roll.gif&#39;,&#39;images/principes_roll.gif&#39;,&#39;images/utilisation_roll.gif&#39;,&#39;images/realisation_roll.gif&#39;,&#39;images/sources_roll.gif&#39;)">
<table border="0" cellpadding="0" cellspacing="0" bordercolor="0">
  <tbody><tr> 
    <td> 
      <div align="left"><a href="http://heigeas.free.fr/laure/ray_tracing/index.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;intro&#39;,&#39;&#39;,&#39;images/intro_roll.gif&#39;,1)"><img name="intro" border="0" src="./REALISATION - Ray Tracing_files/intro.gif" width="240" height="40"></a></div>
    </td>
    <td rowspan="5" colspan="2"> 
      <div align="left"><img src="./REALISATION - Ray Tracing_files/titre.gif" width="600" height="100"></div>
    </td>
  </tr>
  <tr> 
    <td><a href="http://heigeas.free.fr/laure/ray_tracing/principes.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;Principes&#39;,&#39;&#39;,&#39;images/principes_roll.gif&#39;,1)"><img name="Principes" border="0" src="./REALISATION - Ray Tracing_files/principes.gif" width="240" height="40"></a></td>
  </tr>
  <tr> 
    <td><a href="http://heigeas.free.fr/laure/ray_tracing/utilisation.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;utilisation&#39;,&#39;&#39;,&#39;images/utilisation_roll.gif&#39;,1)"><img name="utilisation" border="0" src="./REALISATION - Ray Tracing_files/utilisation.gif" width="240" height="40"></a></td>
  </tr>
  <tr> 
    <td><a href="http://heigeas.free.fr/laure/ray_tracing/realisation.htm" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;realisation&#39;,&#39;&#39;,&#39;images/realisation_roll.gif&#39;,1)"><img name="realisation" border="0" src="./REALISATION - Ray Tracing_files/realisation.gif" width="240" height="40"></a></td>
  </tr>
  <tr> 
    <td><a href="http://heigeas.free.fr/laure/ray_tracing/sources.html" onmouseout="MM_swapImgRestore()" onmouseover="MM_swapImage(&#39;sources&#39;,&#39;&#39;,&#39;images/sources_roll.gif&#39;,1)"><img name="sources" border="0" src="./REALISATION - Ray Tracing_files/sources.gif" width="240" height="40"></a></td>
  </tr>
  <tr> 
    <td colspan="3"> 
      <div align="center"> 
        <hr>
        <!-- #BeginEditable "titre" --><img src="./REALISATION - Ray Tracing_files/realisation_titre.gif" width="240" height="40"><!-- #EndEditable --><br>
        <hr>
      </div>
    </td>
  </tr>
  <tr> 
    <td colspan="3"><!-- #BeginEditable "texte" --> 
      <p align="center"><span class="ray_titre">Réalisation du lancer de 
        rayons<br>
        </span><a href="http://heigeas.free.fr/laure/ray_tracing/realisation.htm#lancer" class="ray_link_n">&gt;&gt; Lancer un rayon</a><br>
        <a href="http://heigeas.free.fr/laure/ray_tracing/realisation.htm#antialiasing" class="ray_link_n">&gt;&gt; Antialiasing</a><br>
        <a href="http://heigeas.free.fr/laure/ray_tracing/realisation.htm#attenuation" class="ray_link_n">&gt;&gt; Atténuation 
        de la lumière</a><a href="http://heigeas.free.fr/laure/ray_tracing/realisation.htm#ombre" class="ray_link_n"><br>
        &gt;&gt; Ombres floues</a><br>
        <a href="http://heigeas.free.fr/laure/ray_tracing/realisation.htm#perlin" class="ray_link_n">&gt;&gt; Bruit de Perlin</a> <br>
        <a href="http://heigeas.free.fr/laure/ray_tracing/realisation.htm#textures" class="ray_link_n">&gt;&gt; Textures procédurales</a><br>
        <a href="http://heigeas.free.fr/laure/ray_tracing/realisation.htm#mapping" class="ray_link_n">&gt;&gt; Textures mapping</a><br>
        <a href="http://heigeas.free.fr/laure/ray_tracing/realisation.htm#bump" class="ray_link_n">&gt;&gt; Bump mapping avec du bruit 
        de Perlin</a><br>
        <a href="http://heigeas.free.fr/laure/ray_tracing/realisation.htm#intersection" class="ray_link_n">&gt;&gt; Résolution 
        d'intersections pour les formes de bases</a><br>
        <a href="http://heigeas.free.fr/laure/ray_tracing/realisation.htm#equation" class="ray_link_n">&gt;&gt; Résolution d'équations 
        algébriques de degrés 4</a><br>
        <a href="http://heigeas.free.fr/laure/ray_tracing/realisation.htm#afaire" class="ray_link_n">&gt;&gt; Ce qui reste à faire 
        ...</a></p>
      <hr>
      <p><a name="lancer"></a><span class="ray_titre">DETAILS DES CALCULS POUR 
        LE LANCER DE RAYONS</span></p>
      <p class="ray">Le rendu par lancer de rayons est un processus récursif 
        et additif, c'est à dire qu'à chaque intersection d'un rayon 
        avec un objet, un ou plusieurs nouveaux rayons sont lancés dans 
        des nouvelles directions fonctions des propriétés matérielles 
        de la surface de l'objet, et que la valeur finale de la lumière 
        au point d'intersection est la somme de la lumière directe en ce 
        point, et de la lumière apportée par les rayons ré-émis.</p>
      <p> </p>
      <p class="ray" align="center"><img src="./REALISATION - Ray Tracing_files/image002.gif" width="215" height="208"></p>
      <p class="ray" align="left"><br>
        <br>
        · <span class="ray-bold_n">Modélisation d'un rayon</span> 
        : Un rayon représente le trajet d'un photon, et donc n'a pas d'épaisseur. 
        Il est modélisé dans l'algorithme de lancer de rayons par 
        une demi-droite de l'espace, c'est à dire un point de départ 
        D et une vecteur directeur V. Ces deux paramètres sont suffisants 
        pour obtenir une équation paramétrée du rayon en 
        fonction du temps. Les points P(x,y,z) par lesquels passe le rayon sont 
        définis par P = D + tV, avec t&gt;=0 . Une fois un rayon lancé, 
        il suffit de calculer son intersection avec les objets de la scène.</p>
      <p align="left"> </p>
      <p class="ray" align="center"><img src="./REALISATION - Ray Tracing_files/image003.gif" width="127" height="71"></p>
      <p class="ray" align="left"><br>
        · <span class="ray-bold_n">Calcul d'intersections</span> : Le calcul 
        de l'intersection d'un rayon avec les objets de la scène est la 
        base de la technique de lancer de rayons. En effet, pour chaque objet 
        composant la scène, il faut il faut obtenir les coordonnées 
        de son intersection (si elle existe) avec le rayon, et ne retenir que 
        l'objet le plus proche de la source du rayon. Ce calcul d'intersection 
        ne peut se faire que si l'on connaît l'équation implicite 
        de la surface représentant l'objet, de la forme S(x,y,z)=0. Pour 
        connaître le point d'intersection avec le rayon lancé, il 
        suffit de remplacer respectivement x, y et z de cette équation 
        par Dx+t.Vx , Dy+t.Vy et Dz+t.Vz , et de trouver la valeur t solution. 
        Une fois les coordonnées du point d'intersection connues, il est 
        facile de calculer la distance de ce point au point de départ du 
        rayon, et donc de déterminer l'objet le plus proche de la source 
        du rayon.</p>
      <p align="left"></p>
      <p align="left"><span class="ray">· </span><span class="ray-bold_n">Normale 
        au point d'intersection </span><span class="ray">: Pour pouvoir connaître 
        les directions des nouveaux rayons à émettre depuis le point 
        d'intersection, il est indispensable de connaître la valeur de la 
        normale à la surface en ce point. Ce calcul est évident 
        pour les formes géométriques de base, mais peut nécessiter 
        des calculs plus poussés pour les objets plus complexes.</span><br>
      </p>
      <hr>
      <p><a name="antialiasing"></a> <span class="ray_titre">L'ANTIALIASING</span></p>
      <p align="center"><img src="./REALISATION - Ray Tracing_files/antialiasing.gif" width="301" height="147"><br>
        <span class="ray">sans et avec anti-aliasing</span></p>
      <p class="ray">La méthode de raytracing reposant sur l'utilisation 
        de rayons de diamètre nul, il se crée sur les bords des 
        objets un phénomène d'aliasing peu réaliste. Pour 
        éviter cet effet de 'marches d'escalier', il existe plusieurs méthodes.</p>
      <p class="ray"><span class="ray-bold_n">· Méthode naïve</span> 
        : Au lieu de lancer un seul rayon par pixel, qui prendra pour intensité 
        la valeur de l'illumination du rayon passant par son centre, on lance 
        plusieurs rayons (4, 9, 16…) par pixel, uniformément répartis 
        sur la surface du pixel. La valeur finale de l'illumination est la moyenne 
        des valeurs de chaque rayon. Cette méthode donne de bons résultats, 
        mais multiplie les temps de calcul par le nombre de rayons que l'on décide 
        de lancer. La plupart des pixels n'ayant pas besoin d'être antialiasés, 
        cette méthode est trop lourde pour être acceptable.<br>
        <span class="ray-bold_n">· Méthode utilisée par notre 
        programme</span>: Puisqu'il est inutile d'effectuer de l'antialiasing 
        pour tous les pixels, on ne lance qu'un seul rayon par pixel. Par contre, 
        la valeur de l'intensité trouvée pour ce pixel est comparée 
        à celle du pixel à gauche et du pixel au dessus. Si un écart 
        trop important est trouvé entre ces trois intensités (supérieur 
        au paramètre AA_THRESHOLD du fichier de description de scène), 
        on lance un nouveau rayon au hasard dans la surface du pixel, et l'on 
        moyenne avec la valeur précédente. Si la nouvelle valeur 
        du pixel est encore trop éloignée de la valeur des deux 
        voisins, on continue de lancer des rayons au hasard dans le pixel et de 
        moyenner avec la valeur précédente, jusqu'à arriver 
        soit à la profondeur maximale autorisée (paramètre 
        ANTIALIASING du fichier de description de scène), soit jusqu'à 
        obtenir une valeur conforme au paramètre du fichier de description 
        de scène. Cette méthode n'est pas infaillible, mais permet 
        dans une large majorité de cas d'obtenir un résultat acceptable, 
        et possède l'avantage de ne pas engendrer de calculs inutiles ralentissant 
        l'exécution du programme.</p>
      <hr>
      <p class="ray"><a name="attenuation"></a><span class="ray_titre">ATTENUATION 
        DE LA LUMIERE</span></p>
      <p class="ray"><span class="ray-bold_n">· Principe </span>: L'atténuation 
        de la lumière peu être spécifiée à l'aide 
        de trois coefficients c1, c2 et c3 et ce uniquement pour les lumière 
        ponctuelles.<br>
        Un facteur d'atténuation fd est alors applique à chacune 
        de ces sources lumineuses, fd étant défini comme suit :</p>
      <p class="ray"> Fd = min( 1 / ( c1 + c2 * dist + c3 * dist*dist ) , 1 )<br>
        Dist étant la distance du point à illuminé à 
        la source lumineuse considérée. </p>
      <p class="ray" align="center"><img src="./REALISATION - Ray Tracing_files/Image18.jpg" width="256" height="192"><img src="./REALISATION - Ray Tracing_files/Image19.jpg" width="256" height="192"><br>
        sans et avec atténuation</p>
      <p class="ray">&nbsp;</p>
      <p class="ray"><span class="ray-bold_n">· Dans notre raytracer</span><br>
        Voici comment spécifier l'atténuation pour une source lumineuse 
        dans notre raytracer :</p>
      <p><span class="ray"> <i>Light_source {<br>
        Location &lt;x,y,z&gt;<br>
        Color &lt;r,g,b&gt;<br>
        Attenuation &lt;c1,c2,c3&gt;<br>
        }</i></span></p>
      <hr>
      <p><a name="ombre"></a> <span class="ray_titre">OMBRES FLOUES</span></p>
      <p class="ray"><span class="ray-bold_n">· Principe </span>: Le principal 
        problème dans une image rendue par lancer de rayon est que les 
        zones d'ombres propres et portées des objets sont très franches. 
        Il est cependant possible, mais pour un coût plus élevé 
        en calculs, de rendre celles-ci plus ou moins floues en utilisant une 
        petite astuce.<br>
        Celle-ci consiste à lancer pour chaque pixel de l'image, non un 
        seul, mais plusieurs rayons d'ombres vers chaque source lumineuse considérée, 
        en faisant bouger à chaque fois de façon aléatoire 
        ces mêmes sources lumineuses. Chaque rayon d'ombre lancé 
        va ou non apporter de la lumière sur le pixel en question, une 
        simple moyenne suffit alors à déterminer la luminosité 
        finale.<br>
        Les pixels situés à la limite d'une zone d'ombre vont donc 
        se trouver parfois illuminés et parfois dans l'ombre, et vont donc 
        constituer une limite en dégradé partant de l'ombre à 
        la lumière. Si les ombres floues sont activées , il est 
        alors préférable d'activer également l'antialiasing 
        afin de lisser encore plus les limites ombres -lumières.</p>
      <p class="ray" align="center"><img src="./REALISATION - Ray Tracing_files/Image20.jpg" width="160" height="120"><img src="./REALISATION - Ray Tracing_files/Image21.jpg" width="160" height="120"><br>
        sans et avec ombres floues</p>
      <p class="ray-bold_n">· Dans notre raytracer</p>
      <p class="ray">Voici comment spécifier les ombres floues dans notre 
        raytracer :</p>
      <p class="ray"><i>Global_setting {<br>
        Soft_Shadow x<br>
        Shadow_Ray y<br>
        }</i></p>
      <p class="ray">y est un entier indiquant le nombre de rayons d'ombres à 
        générer pour chaque pixel<br>
        x est un nombre décimal indiquant l'intensité du déplacement 
        des sources lumineuses. Par exemple, si x vaut 2, cela signifie que les 
        sources lumineuses vont se déplacer dans un cube de taille 2, centré 
        sur leur position initiale.</p>
      <p class="ray">Bien entendu, plus x est grand plus les ombres sont floues, 
        mais plus il faut augmenter y pour que les transitions soient uniformes.<br>
      </p>
      <hr>
      <p><a name="perlin"></a><span class="ray_titre">LE BRUIT DE PERLIN</span></p>
      <p class="ray">Afin de modéliser des motifs complexes (nuages, marbres 
        …), il est nécessaire d'avoir à disposition des algorithmes 
        capables de les générer de façon automatique. Pour 
        introduire une grande diversité et par ailleurs un meilleur réalisme, 
        ces algorithmes se doivent d'introduire de l'aléatoire dans ces 
        motifs. C'est l qu'intervient le bruit de Perlin, car bien entendu, il 
        ne s'agit pas de générer des motifs totalement aléatoire, 
        car on obtiendrait bien sur, dans ce cas, un motif " moucheté 
        " du plus mauvais effet. Le bruit de Perlin, qualifié de bruit 
        cohérent, permet de palier ce problème. </p>
      <p class="ray" align="center">Bruit totalement aléatoire<br>
        <img src="./REALISATION - Ray Tracing_files/image017.jpg" width="128" height="128"></p>
      <p></p>
      <p></p>
      <p></p>
      <p class="ray" align="center">Bruit de Perlin<br>
        <img src="./REALISATION - Ray Tracing_files/image016.jpg" width="128" height="128"></p>
      <p class="ray"><br>
        De plus, il présente l'avantage de pouvoir s'écrire sous 
        le forme fNoise(x,y,z) et ainsi d'associer directement à un point 
        dans l'espace, une valeur qui peu ensuite être convertie en couleur 
        (pour faire de la texture procédurale) ou en hauteur (pour faire 
        du bumpmapping), ce qui est très pratique pour l'insérer 
        dans un moteur de raytracing. En effet la plupart des algorithmes de génération 
        de bruit cohérent (pour générer des montagnes fractales 
        par exemples), créent les motifs de proche en proches de façon 
        récursive et ne peuvent donc associer de façon directe une 
        valeur à un point.</p>
      <p class="ray" align="left">Le principe pour générer du bruit 
        de Perlin est d'additionner plusieurs fonctions de bruit d'amplitude et 
        de fréquence différentes, ce qui permet d'avoir cet effet 
        de cohérence dans le bruit généré. Voici un 
        exemple ci-dessous :</p>
      <p class="ray" align="center"><br>
        Bruit de Perlin avec fonction à une dimension :<br>
        <img src="./REALISATION - Ray Tracing_files/image025.gif" width="582" height="50"> </p>
      <p></p>
      <p class="ray" align="center">Bruit de Perlin avec fonction à deux 
        dimensions :<br>
        <img src="./REALISATION - Ray Tracing_files/image007.gif" width="658" height="135"> <br>
      </p>
      <p></p>
      <p></p>
      <p></p>
      <hr>
      <p></p>
      <p><a name="textures"></a> <span class="ray_titre">TEXTURE PROCEDURALE</span></p>
      <p class="ray">Il s'agit ici de déterminer la couleur de tout point 
        de coordonnées (x1, x2, x3) dans le repère de la scène 
        à l'aide d'une procédure.<br>
        On peut ainsi définir toute sorte de procédures. En voici 
        2 exemples :</p>
      <p class="ray"><span class="ray-bold_n">· Checker</span><br>
        Le checker est défini par 2 couleurs c1, c2 et la longueur L des 
        carreaux.<br>
        Ici on calcule la parité pi de la partie entière de xi / 
        L.<br>
        Si xi &lt; 0 alors on prends la parité inverse.</p>
      <p class="ray" align="center"><img src="./REALISATION - Ray Tracing_files/Image22.jpg" width="256" height="128"><br>
      </p>
      <p></p>
      <p></p>
      <p class="ray" align="left">Voici l'algorithme déterminant la couleur 
        en fonction des pi :</p>
      <p class="ray" align="center"><br>
        <img src="./REALISATION - Ray Tracing_files/image048.gif" width="365" height="201"> </p>
      <p><span class="ray-bold_n">· Perlin</span><span class="ray"><br>
        La couleur d'un point peut être donnée à partir d'un 
        bruit de Perlin. Ceci nous permet d'obtenir des textures très réalistes 
        comme le bois ou le marbre.</span></p>
      <p class="ray-bold_n">· Bruit de perlin seul</p>
      <p class="ray">Pour appliquer le bruit de perlin comme texture procédurale, 
        il suffit de demander pour chaque point (x,y,z) dont on veut connaître 
        la couleur, la valeur n de fNoise(x,y,z). Selon la valeur de n, on interpole 
        alors une couleur à partir d'une table de couleur.<br>
      </p>
      <p class="ray" align="center"><img src="./REALISATION - Ray Tracing_files/Image25.jpg" width="250" height="250"> 
      </p>
      <p class="ray">Par exemple : </p>
      <p class="ray">Soit la table de couleur suivant :</p>
      <p class="ray">Si n = v1 alors couleur = (r1,g1,b1)<br>
        Si n = v2 alors couleur = (r2,g2,b2)<br>
        Si n = v3 alors couleur = (r3,g3,b3)<br>
        Si n = v4 alors couleur = (r4,g4,b4)</p>
      <p class="ray">Avec v1 &lt; v2 &lt; v3 &lt; v4</p>
      <p class="ray">Si v2 &lt; n &lt; v3, alors on prendra comme la couleur (r,g,b) 
        avec :<br>
        r = r2 * (n-v2) / (v3-v2) + r3 * (v3-n) / (v3-v2)<br>
        g = g2 * (n-v2) / (v3-v2) + g3 * (v3-n) / (v3-v2)<br>
        b = b2 * (n-v2) / (v3-v2) + b3 * (v3-n) / (v3-v2)</p>
      <p></p>
      <p class="ray"><span class="ray-bold_n">· Effet marbré</span><br>
        <br>
        Pour obtenir un effet marbre, il suffit de remplacer fNoise(x,y,z) par 
        : </p>
      <p class="ray">fMarbre(x,y,z) = cos( x + fNoise(x,y,z) )</p>
      <p class="ray-bold_n">· Effet bois</p>
      <p class="ray">Pour obtenir un effet bois, il suffit de remplacer fNoise(x,y,z) 
        par : </p>
      <p class="ray"> v = 20 * fNoise(x,y,z)<br>
        fBois(x,y,z) = v - partieEntiere(v) <br>
      </p>
      <p class="ray" align="center"><img src="./REALISATION - Ray Tracing_files/Image26.jpg" width="250" height="250"> 
      </p>
      <p class="ray-bold_n">· Dans notre raytracer</p>
      <p class="ray">Voici comment spécifier ces textures procédurales 
        dans notre ray-tracer :</p>
      <p class="ray"> <i>Objet {<br>
        PARAMETRES_OBJET<br>
        Pigment {<br>
        Perlin {<br>
        amplitude,frequence,octave,intensite<br>
        }<br>
        Scale &lt;sx,sy,sz&gt;<br>
        Rotate &lt;rx,ry,rz&gt;<br>
        Translate &lt;tx,ty,tz&gt;<br>
        }<br>
        }</i></p>
      <p class="ray"><i>intensite</i> est un coefficient multiplicateur appliqué 
        au bruit<br>
        <i>octave</i> est le nombres de fonctions de bruit additionnée<br>
        <i>frequence</i> est la fréquence de la fonction de bruit<br>
        <i>amplitude</i> est l'amplitude de la fonction de bruit</p>
      <p class="ray"><i>rotate</i>, <i>translate</i> et <i>scale</i> sont des 
        transformation apportées sur le motif de la texture procédurale.</p>
      <p class="ray">Pour l'effet marbre il suffit de remplacer le mot clé<i> 
        perlin</i> par <i>marble</i> et pour l'effet bois de remplacer<i> perlin</i> 
        par<i> wood</i>.</p>
      <hr>
      <p class="ray"><a name="mapping"></a><span class="ray_titre">TEXTURE MAPPING</span></p>
      <p class="ray">Le principe est d'appliquer une image sur une surface, de 
        façon répétitive ou non.<br>
        Il faut donc faire correspondre un point de l'image à chaque point 
        de la surface considérée.</p>
      <p class="ray">Pour permettre cette correspondance il nous faut tout d'abord 
        déterminer un paramétrage de la surface : <br>
        x = fx(u, v)<br>
        y = fy(u, v)<br>
        z = fz(u, v)</p>
      <p class="ray">Puis nous faisons correspondre à (u, v) un pixel (i, 
        j) de l'image.</p>
      <p class="ray" align="center"><img src="./REALISATION - Ray Tracing_files/image034.gif" width="327" height="193"></p>
      <p></p>
      <p></p>
      <p></p>
      <p></p>
      <p></p>
      <p class="ray"><br>
        <span class="ray-bold_n">· Mapping sur le cercle</span></p>
      <p class="ray">Les équations paramétriques du cercle sont 
        les suivantes :</p>
      <p> </p>
      <p></p>
      <p class="ray">x = r sin u<br>
        y = r cos u sin v<br>
        z = r cosu cos v<br>
        u varie dans [-pi /2, pi/2] et v varie dans [0, 2pi[.</p>
      <p class="ray">Soit n la fréquence de répétition de 
        l'image sur la sphère, H la hauteur de l'image, L sa largeur. </p>
      <p class="ray">Calcul du pixel i correspondant au paramètre u :<br>
        t = n ( u / P + 0.5)<br>
        i = PartieEntière ( H (t-PartieEntière(t))</p>
      <p class="ray">Calcul du pixel j correspondant au paramètre v :<br>
        t = n ( u / (2P))<br>
        j = PartieEntière ( L (t-PartieEntière(t))</p>
      <p class="ray">Pour n = 1 on obtient le résultat suivant :</p>
      <p class="ray" align="center"><img src="./REALISATION - Ray Tracing_files/image0008.jpg" width="191" height="189"></p>
      <p></p>
      <p></p>
      <p></p>
      <p class="ray"><span class="ray-bold_n">· Mapping sur le plan</span></p>
      <p class="ray">Les équations paramétriques du plan d'équation 
        x = 0 sont les suivantes :<br>
        x = 0<br>
        y = v + n/2<br>
        z = u - m/2<br>
        Soit n la largeur désirée de l'image sur le plan, H la hauteur 
        de l'image, L sa largeur initiale et m la hauteur sur le plan égale 
        à n.H / L.</p>
      <p class="ray">Calcul du pixel i correspondant au paramètre u : <br>
        t = m.PartieEntière(u / m)<br>
        i = PartieEntière ( H (u - t) / m)<br>
        si i &lt; 0 alors i = -i. </p>
      <p class="ray">Calcul du pixel j correspondant au paramètre v :<br>
        t = n.PartieEntière(v / n)<br>
        j = PartieEntière ( L (v - t) / n)<br>
        si j &lt; 0 alors j = -j.</p>
      <p class="ray"><br>
        Ainsi, dans le cas suivant :<br>
        - camera "orthographique" définie avec une largeur de 
        projection de n,<br>
        - un plan parallèle à la camera à qui on applique 
        l'image avec une largeur de n,<br>
        - une image de sortie de la même taille (H.L pixels) que l'image 
        appliquée sur le plan,<br>
        on obtient une image de sortie identique à l'image appliquée, 
        hormis les effets de lumières, d'ombres, de réflexions ou 
        de transparences apportés par le lancé de rayon.<br>
      </p>
      <hr>
      <p class="ray"> <a name="bump"></a><span class="ray_titre">BUMP MAPPING 
        avec du bruit de Perlin</span></p>
      <p class="ray"><span class="ray-bold_n">· Principe</span><br>
        Le bump-mapping est une technique permettant de donner un aspect non lisse 
        à un objet géométriquement lisse. Il consiste en 
        l'altération des normales d'un objet, ce qui modifie par la même 
        l'illumination des points de l'objet situés à la base de 
        la normale.</p>
      <p class="ray" align="center"><img src="./REALISATION - Ray Tracing_files/Image27.jpg" width="250" height="250"></p>
      <p class="ray">La technique utilisée ici est d'utiliser le même 
        bruit de perlin que pour les textures procédurales, mais de considérer 
        les valeurs fournis par la fonction de bruit, non pas comme une couleur, 
        mais comme une hauteur.</p>
      <p class="ray-bold_n">· Dans notre raytracer</p>
      <p class="ray">Voici comment spécifier du bump-mapping dans notre 
        raytracer :<br>
        <i>Objet {<br>
        PARAMETRES_OBJET<br>
        Pigment { … }<br>
        Normal {<br>
        Perlin { <br>
        amplitude,frequence,octave,intensite <br>
        Scale &lt;sx,sy,sz&gt;<br>
        Rotate &lt;rx,ry,rz&gt;<br>
        Translate &lt;tx,ty,tz&gt;<br>
        }<br>
        }<br>
        }</i></p>
      <p></p>
      <p class="ray">Pour modifier la normale au point (x,y,z) d'une surface, 
        on crée le vecteur v dont les directions x,y et z suivent les variations 
        du bruit de perlin autour d'un point considéré :</p>
      <p class="ray"> V[0] = fNoise (x-e,y,z) - fNoise (x+e,y,z) <br>
        V[1] = fNoise (x,y-e,z) - fNoise (x,y+e,z) <br>
        V[2] = fNoise (x,y,z-e) - fNoise (x,y,z+e) </p>
      <p><span class="ray">On altère ensuite la normale au point (x,y,z) 
        en lui additionnant v. Reste seulement a choisir les bon paramètres 
        pour générer le bon bruit de perlin !</span><br>
      </p>
      <hr>
      <p><a name="intersection"></a><span class="ray_titre">RESOLUTION D'INTERSECTIONS 
        POUR LES FORMES DE BASES</span><br>
        <span class="ray">L'algorithme de raytracing engendre un nombre très 
        important de calculs sur des nombres réels, dont la majeure partie 
        consiste à déterminer des intersections objet-rayon. La 
        résolution des problèmes d'intersections revient essentiellement 
        à trouver les racines de polynômes, jusqu'au 4eme degré 
        pour le tore et le cube troué.</span></p>
      <p class="ray"><span class="ray-bold_n">Les calculs d'intersections et de 
        normales</span><span class="ray"><br>
        Chaque objet de la scène est défini dans son repère 
        propre. Lors de la description de la scène, les paramètres 
        de translation, rotation et mise à l'échelle permettent 
        de définir une matrice de transformation propre à chaque 
        objet, qui permet de passer des coordonnées de points ou de vecteurs 
        dans le repère absolu à celles dans le repère de 
        l'objet, et inversement. Cette transformation se fait grâce à 
        des produits matrice-vecteur, et n'est possible que parce que l'on utilise 
        des coordonnées homogènes pour représenter les points 
        de l'espace.<br>
        Pour chaque objet, il suffit de définir les méthodes calculant 
        l'intersection avec un rayon et la normale en un point ; il est donc aisé 
        d'ajouter de nouveau objets au programme.<br>
        Dans la fonction intersection, on calcule le point d'intersection entre 
        le rayon et l'objet. Pour cela, il est tout d'abord nécessaire 
        d'appliquer la matrice inverse de transformation sur le rayon pour que 
        ce dernier soit dans le même repère que l'objet. Par la suite, 
        il faut effectuer le calcul d'intersection propre à chaque objet, 
        que l'on détaille en annexe. Pour finir, on applique la matrice 
        de transformation sur le point d'intersection pour le ramener dans le 
        repère de la scène, et on retourne la valeur de la distance 
        entre ce point d'intersection et le point origine du rayon.<br>
        Pour le calcul de la normale au point d'intersection, il est également 
        nécessaire d'utiliser la matrice inverse de transformation pour 
        placer le point d'intersection dans le repère de l'objet. Le rayon 
        est transformé dans le repère de l'objet. Puis on prend 
        en compte le côté d'où provient le rayon par rapport 
        à l'objet (intérieur, extérieur, dessus, dessous) 
        à l'aide du produit scalaire du rayon et de la normale. Pour finir, 
        on normalise cette normale, et on lui applique la matrice de transformation 
        pour la replacer dans le repère de la scène.<br>
        Les équations mathématiques à résoudre pour 
        chaque objet sont détaillées ci-dessous.</span></p>
      <p class="ray" align="center"><a href="http://heigeas.free.fr/laure/ray_tracing/cone.html" class="ray_link_n">&gt;&gt; 
        cone</a><br>
        <a href="http://heigeas.free.fr/laure/ray_tracing/cube.html" class="ray_link_n">&gt;&gt; cube</a><br>
        <a href="http://heigeas.free.fr/laure/ray_tracing/cubetroue.html" class="ray_link_n">&gt;&gt; cubeTroue</a><br>
        <a href="http://heigeas.free.fr/laure/ray_tracing/cylindre.html" class="ray_link_n">&gt;&gt; cylindre</a><br>
        <a href="http://heigeas.free.fr/laure/ray_tracing/parallelogram.html" class="ray_link_n">&gt;&gt; parallélogrammme</a><br>
        <a href="http://heigeas.free.fr/laure/ray_tracing/plan.html" class="ray_link_n">&gt;&gt; plan</a><br>
        <a href="http://heigeas.free.fr/laure/ray_tracing/prisme.html" class="ray_link_n">&gt;&gt; prisme</a><br>
        <a href="http://heigeas.free.fr/laure/ray_tracing/pyramid.html" class="ray_link_n">&gt;&gt; pyramide</a><br>
        <a href="http://heigeas.free.fr/laure/ray_tracing/sphere.html" class="ray_link_n">&gt;&gt; sphere</a><br>
        <a href="http://heigeas.free.fr/laure/ray_tracing/tore.html" class="ray_link_n">&gt;&gt; tore</a><a href="http://heigeas.free.fr/laure/ray_tracing/triangle.html" class="ray_link_n"><br>
        &gt;&gt; triangle</a><br>
      </p>
      <hr>
      <p><a name="equation"></a><span class="ray_titre">RESOLUTION D'EQUATIONS 
        POLYNOMIALES DE DEGRES 4</span><br>
        <span class="ray">Pour trouver les racines de polynômes jusqu'au 
        degré 4, nous utilisons la méthode de François Vieta, 
        qui date de 1735.</span></p>
      <p class="ray">Soit à résoudre<span class="ray-bold_n"> </span></p>
      <p class="ray" align="center"><img src="./REALISATION - Ray Tracing_files/image042.gif" width="306" height="36"></p>
      <p class="ray">Le cas où a3 et a4 sont nuls, ce qui revient à 
        résoudre une équation du 2nd degrés, n'est pas traité 
        ici. En effet ce cas est considéré comme trivial.<br>
        Ici la résolution proposée est purement algébrique.</p>
      <p class="ray-bold_n">Cas où a4 est nul et a3 non nul : résolution 
        d'une équation du 3ième degrés </p>
      <p class="ray" align="center"><img src="./REALISATION - Ray Tracing_files/image039.gif" width="431" height="383"></p>
      <p class="ray" align="left"><br>
        <span class="ray-bold_n">Cas où a4 est non nul : résolution 
        d'une équation du 4ième degrés<br>
        Methode de Francois Vieta (1735)</span></p>
      <p class="ray" align="center"><img src="./REALISATION - Ray Tracing_files/image040.gif" width="711" height="364"><br>
        <img src="./REALISATION - Ray Tracing_files/image041.gif" width="711" height="209"> <br>
      </p>
      <hr>
      <p><a name="afaire"></a><span class="ray_titre">CE QUI RESTE A FAIRE...<br>
        <span class="ray">Notre programme permet d'obtenir des images photoréalistes 
        de qualité, meilleures que l'algorithme du z-buffer combiné avec ceux 
        de Gouraud ou Phong qui ne prennent pas en compte la réflexion et la réfraction. 
        D'autre part, le lancer de rayon ne se limite pas comme les algorithmes 
        précédents à la seule visualisation des modèles facétisés, c'est à dire 
        composé exclusivement de polygones. Il permet la visualisation de surfaces 
        implicites. Cependant, les temps de calculs sont généralement considérablement 
        longs et la visualisation ne peut pas se faire en temps réel comme avec 
        le z-buffer. De plus il est de moins bonne qualité que l'algorithme de 
        radiosité qui modélise mieux les phénomènes de transport d'énergie.</span></span></p>
      <p><span class="ray_titre"><span class="ray">L'une des améliorations à apporter 
        à notre programme est d'implémenter le lancer de rayons arrière. Cette 
        méthode consiste à lancer des rayons depuis les sources de lumière vers 
        la scène, permettant de déterminer les sources de lumière secondaires 
        (la réflexion de la source de lumière sur un miroir par exemple), afin 
        d'obtenir des résultats plus réalistes.</span></span></p>
      <p><span class="ray_titre"><span class="ray">Notre " raytracer " traite 
        des scènes comportant des objets de base relativement simples, mais néanmoins 
        suffisants pour construire des scènes intéressantes. Il serait possible 
        de rajouter quelques objets de bases supplémentaires, tels que :<span class="ray-bold_n"><br>
        </span></span></span><span class="ray-bold_n"><span class="ray_titre"><span class="ray">· 
        les ellipsoïdale, hyperboloïdale</span></span></span><span class="ray_titre"><span class="ray"> 
        (formes super-quadratiques) d 'équations implicites de la forme : (x/a)2/p 
        + (y/b)2/p + (z/c)2/q = 1 ou (x/a)2/p + (y/b)2/p - (z/c)2/q = 1<br>
        <span class="ray-bold_n">· les meta-balls</span> d 'équations implicites 
        de la forme : a1 * exp ( - b1 * f1 (x,y,z)) + ... + an * exp ( - bn * 
        fn (x,y,z)) = 0.<br>
        · des objets plus complexes tels que les<span class="ray-bold_n"> Constructive 
        Solid Geometry</span> (C.S.G.), arbres dont les feuilles sont des volumes 
        simples.</span></span></p>
      <p><span class="ray_titre"><span class="ray">Le <span class="ray-bold_n">calcul 
        d'intersections</span> constituant la majeure quantité de calculs à effectuer, 
        il y aurait plusieurs façons pour pouvoir accélérer cette partie. En effet, 
        nous avons ici traité la méthode naïve consistant à calculer l'intersection 
        d'un rayon avec toutes les surfaces de la scène puis à sélectionner la 
        plus proche. La première optimisation est de diminuer le nombre de rayons 
        primaires en projetant les objets de la scène sur l'écran. La deuxième 
        est l'utilisation des volumes simples englobants un ensemble d'objets, 
        à savoir que si un rayon n'intersecte pas ce volume, il est inutile de 
        faire le calcul d'intersection avec tous les objets qu'il contient. Mais 
        la génération de ces volumes englobants s'est avérée problématique. Une 
        autre solution est de décomposer l'espace en voxels, puis à l'aide de 
        méthodes incrémentales (de type Bresenham) on détermine la succession 
        de voxels rencontrés par le rayon et donc les objets susceptibles d'intersecter 
        le rayon, ce qui réduit les temps de calcul. Pour obtenir une bonne efficacité, 
        il faut un grand nombre de voxels et le coût mémoire sera donc énorme. 
        La technique de l'arbre octal tente de palier à cet inconvénient : la 
        scène est divisée en 8 voxels jointifs, et eux-même divisés en sous voxels, 
        récursivement tant qu'un voxel contient un nombre trop important d'objets. 
        Cette méthode permet de créer un arbre non-symétrique où 8 branches partent 
        de chaque nœud, et où chaque feuille est une liste d'objets contenus dans 
        le voxel correspondant. L'arbre octal réduit considérablement le coût 
        mémoire de par la moindre occupation des zones vides. </span></span></p>
      <!-- #EndEditable --></td>
  </tr>
  <tr> 
    <td class="ray" colspan="3"> 
      <hr>
    </td>
  </tr>
  <tr> 
    <td class="ray" colspan="3" height="18">
      <div align="center"><span class="ray-bold">Auteurs :</span> <a href="http://heigeas.free.fr/laure/ray_tracing/mailto%20:%20bonfortt@ufrima.imag.fr%20" class="ray_link">Thomas 
        Bonfort</a>, <a href="http://heigeas.free.fr/laure/ray_tracing/mailto%20:%20chaigned@ufrima.imag.fr%20" class="ray_link">Delphine 
        Chaigneau</a>, <a href="http://heigeas.free.fr/laure/ray_tracing/mailto%20:%20galizzio@ufrima.imag.fr%20" class="ray_link">Olivier 
        Galizzi</a>, <a href="http://heigeas.free.fr/laure/ray_tracing/mailto%20:%20heigeasl@ufrima.imag.fr%20" class="ray_link">Laure 
        Heigeas</a> </div>
      <div align="right"></div>
    </td>
  </tr>
</tbody></table>

<!-- #EndTemplate -->
</body></html>